- **Why** should we use subgraphs?
- **When** do we use subgraphs?
- **How** do we use subgraphs?
- **Where** do we use subgraphs?

### WHY?
- **Quick Access** to historical blockchain data with **hardly any delay**
- Very **straightforward**
- Serve as off-chain **data storage** with Graph QL API and virtually **no limits** 
- Simple **data processing** and **manipulation**
- **Quick** and **easy**

### WHEN?
Subgraphs are useful for the following cases:

- If the chain is supported (there are still some chains that aren't supported)
- When working with large volumes of historical data on a regular basis
- If it’s OK to wait a short time when listing new blocks, as it takes time for subgraphs to catch up
- When you’re _not_ working and/or aggregating data from numerous different data sources, because you still can't have one deployment on multiple chains

### HOW?
You can use a template for deployment, run some script, configure it, and it will deploy automatically. Alternatively, you can start from scratch.
Check the prerequisites for anything you need to install.

Create a subgraph in [link](thegraph.com)

### WHERE?
You don't need an online repository, you can deploy it automatically. You can find an example of the live playground here:
https://thegraph.com/hosted-service/subgraph/hehe100596/template-subgraph


## TASK

- Using the **Contract Address** and **Processed Events**, you can easily create a subgraph or API with the **User Address** and **Token Address** as input. You get an accumulated mosaic from these events
- Add **Title** and **Subtitle**. There’s an option to hide it from Explorer while keeping it accessible provided you have the address
- Click **Create** (you might wait a moment for it to be created)
- Once you've saved it, it will be created in easy-to-read formatting

This is the end of the first step. At this point you can adjust the contract manually and you have everything you need. You can remove most of the code since you won’t need it, but it’s also OK to leave it.

### Graph base commands
- graph codegen
- graph build
- graph create <subgraph-name>
- graph deploy <subgraph-name>


### Package JSON
This package contains all the script you will be using. You use this when other users deploy to the same space. Those users need to authenticate the first time they use it. They will receive information about how to deploy and they will receive the access key.

### Subgraph Yaml
This should have all the information you need to define what you are looking for, but you can make some adjustments here, such as entities, address, etc. You don’t need to go to the whole chain. From that one block, you can make sure that no blocks are skipped - as an extra security measure.
  
At this point, you have generated exactly what it should be looking for in the blockchain, as well as the information on how it should generate all the classes in the background.

You can see from these steps how much information is autogenerated and how much quicker it is compared to doing this manually. As a result of the autogeneration, based on JSON and Schema, etc., multiple scripts and classes may be generated in the background, meaning you need to run **Codegen** to make changes to the files.

### Graph QL API
You should think of this as an interface for the data retrieval

### Last step: mapping
You use mapping to transform data from the blockchain (event) into a data entity.

Write the mapping in a subset of TypeScript called AssemblyScript, which can be compiled down to WASM. For every event handler, you should create an export function. That function only has one argument, which is an event object.
  
Basic entity functions: 
  - save
  - load
  - remove
  
Get data from the contract: any state variable that is marked public or any view function that can be accessed.

Create a new user ID, with data associated with that specific ID, and then populate all the fields.
